<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>ProView TIFF PWA</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1e293b">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    
    <style>
        body { touch-action: none; overscroll-behavior: none; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Loading Spinner */
        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 30px; height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Canvas visual handling */
        canvas, img { 
            transition: transform 0.1s ease-out; 
            transform-origin: 0 0;
            max-width: 100%; 
            max-height: 100%;
        }
        .active-thumb { border-color: #3b82f6; opacity: 1; transform: scale(1.05); }
    </style>
</head>
<body class="bg-slate-900 text-white h-screen flex flex-col overflow-hidden font-sans select-none">

    <header class="bg-slate-800/90 backdrop-blur border-b border-slate-700 p-3 flex items-center justify-between shrink-0 z-20">
        <div class="flex items-center gap-3">
            <div class="p-1.5 bg-blue-600 rounded">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
            </div>
            <h1 class="font-bold tracking-wide text-sm sm:text-lg">ProView <span class="text-blue-400">TIFF</span></h1>
        </div>

        <div class="flex gap-2">
            <button onclick="exportToJPG()" id="desktopExport" class="hidden sm:flex items-center gap-2 bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded-full text-sm transition">
                <span>Save JPG</span>
            </button>
            
            <input type="file" id="fileInput" multiple accept=".tif,.tiff,image/*" class="hidden">
            <button onclick="document.getElementById('fileInput').click()" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-1.5 rounded-full text-sm font-medium shadow-lg active:scale-95 transition">
                Open Files
            </button>
        </div>
    </header>

    <main class="flex-1 relative bg-slate-950 overflow-hidden flex items-center justify-center" id="gestureZone">
        
        <div id="emptyState" class="flex flex-col items-center text-slate-600 p-8 text-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-4 opacity-30" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
            <p class="text-lg font-medium text-slate-500">No Images Selected</p>
            <p class="text-xs mt-2 text-slate-600">Supports Multi-page TIFF, JPG, PNG</p>
        </div>

        <div id="loader" class="hidden absolute inset-0 z-50 bg-slate-900/80 flex flex-col items-center justify-center backdrop-blur-sm">
            <div class="loader mb-2"></div>
            <p class="text-blue-400 text-xs font-mono animate-pulse">PROCESSING...</p>
        </div>

        <div id="canvasWrapper" class="w-full h-full flex items-center justify-center overflow-hidden hidden relative">
            <canvas id="mainCanvas" class="shadow-2xl"></canvas>
            <img id="mainImage" class="hidden shadow-2xl" />
        </div>

        <div id="fileInfo" class="hidden absolute top-4 left-1/2 -translate-x-1/2 bg-black/50 backdrop-blur px-3 py-1.5 rounded-full text-xs border border-white/10 pointer-events-none">
            <span id="fileName" class="text-blue-200 font-medium">filename.tif</span>
            <span class="mx-2 text-slate-500">|</span>
            <span id="pageInfo" class="text-slate-300">1/1</span>
        </div>

        <button id="installBtn" class="hidden absolute bottom-20 right-4 bg-blue-600 text-white px-4 py-2 rounded-full shadow-xl z-50 text-sm font-bold">
            Install App
        </button>
    </main>

    <footer class="bg-slate-800 border-t border-slate-700 h-20 shrink-0 flex items-center px-2 gap-2 overflow-x-auto hide-scrollbar z-20" id="thumbnailStrip">
        </footer>

    <div id="mobileToolbar" class="md:hidden bg-slate-900/95 backdrop-blur border-t border-slate-800 p-2 flex justify-between items-center pb-safe z-30">
        
        <button onclick="prevTiffPage()" class="flex flex-col items-center p-2 text-slate-400 active:text-blue-400">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
            <span class="text-[10px] mt-1">Pg Up</span>
        </button>

        <button onclick="rotate90()" class="flex flex-col items-center p-2 text-slate-400 active:text-blue-400">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
            <span class="text-[10px] mt-1">Rotate</span>
        </button>

        <button onclick="toggleCrop()" id="cropBtn" class="flex flex-col items-center p-2 text-slate-400 active:text-blue-400">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>
            <span class="text-[10px] mt-1">Crop</span>
        </button>

        <button onclick="showHistogram()" class="flex flex-col items-center p-2 text-slate-400 active:text-blue-400">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
            <span class="text-[10px] mt-1">Stats</span>
        </button>

        <button onclick="exportAllZip()" class="flex flex-col items-center p-2 text-slate-400 active:text-blue-400">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
            <span class="text-[10px] mt-1">ZIP All</span>
        </button>

        <button onclick="nextTiffPage()" class="flex flex-col items-center p-2 text-slate-400 active:text-blue-400">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            <span class="text-[10px] mt-1">Pg Dn</span>
        </button>
    </div>

    <script>
        // --- STATE MANAGEMENT ---
        const state = {
            files: [],
            currIndex: -1,
            tiffPages: [],
            currTiffPage: 0,
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            pinchStartDist: 0,
            cropMode: false,
            cropStart: null
        };

        // --- ELEMENTS ---
        const els = {
            fileInput: document.getElementById('fileInput'),
            canvasWrapper: document.getElementById('canvasWrapper'),
            mainCanvas: document.getElementById('mainCanvas'),
            mainImage: document.getElementById('mainImage'),
            emptyState: document.getElementById('emptyState'),
            loader: document.getElementById('loader'),
            fileInfo: document.getElementById('fileInfo'),
            fileName: document.getElementById('fileName'),
            pageInfo: document.getElementById('pageInfo'),
            thumbStrip: document.getElementById('thumbnailStrip'),
            gestureZone: document.getElementById('gestureZone'),
            cropBtn: document.getElementById('cropBtn'),
            installBtn: document.getElementById('installBtn')
        };

        // --- INITIALIZATION ---
        els.fileInput.addEventListener('change', handleFileSelect);
        
        // PWA Install Logic
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            els.installBtn.classList.remove('hidden');
        });
        els.installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) return;
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            if (outcome === 'accepted') els.installBtn.classList.add('hidden');
            deferredPrompt = null;
        });

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js')
            .then(() => console.log('SW Registered'))
            .catch(err => console.log('SW Error', err));
        }

        // --- INPUT HANDLING ---
        async function handleFileSelect(e) {
            const raw = Array.from(e.target.files);
            const valid = raw.filter(f => f.type.startsWith('image/') || f.name.toLowerCase().endsWith('.tif') || f.name.toLowerCase().endsWith('.tiff'));
            
            if (valid.length === 0) return showToast("No valid images found");

            state.files = valid;
            state.currIndex = 0;
            
            els.emptyState.classList.add('hidden');
            els.canvasWrapper.classList.remove('hidden');
            els.canvasWrapper.classList.add('flex');
            els.fileInfo.classList.remove('hidden');

            generateThumbnails();
            await loadCurrentImage();
        }

        // --- RENDERING CORE ---
        async function loadCurrentImage() {
            if (state.currIndex < 0) return;
            
            resetTransform();
            state.cropMode = false;
            updateCropUI();
            
            const file = state.files[state.currIndex];
            els.fileName.textContent = file.name;
            
            els.loader.classList.remove('hidden');
            
            updateActiveThumb();

            try {
                if (file.name.toLowerCase().endsWith('tif') || file.name.toLowerCase().endsWith('tiff')) {
                    await loadTiff(file);
                } else {
                    await loadStandard(file);
                }
            } catch (e) {
                console.error(e);
                showToast("Error loading image");
            } finally {
                els.loader.classList.add('hidden');
            }
        }

        function loadStandard(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    els.mainCanvas.classList.add('hidden');
                    els.mainImage.classList.remove('hidden');
                    els.mainImage.src = e.target.result;
                    state.tiffPages = [];
                    els.pageInfo.textContent = `${state.currIndex + 1}/${state.files.length}`;
                    resolve();
                }
                reader.readAsDataURL(file);
            });
        }

        async function loadTiff(file) {
            const buffer = await file.arrayBuffer();
            const ifds = UTIF.decode(buffer);
            state.tiffPages = ifds;
            state.currTiffPage = 0;
            state.currentTiffBuffer = buffer; // Store for page switching
            await renderTiffPage();
        }

        async function renderTiffPage() {
            if (!state.tiffPages.length) return;
            
            const page = state.tiffPages[state.currTiffPage];
            UTIF.decodeImage(state.currentTiffBuffer, page);
            const rgba = UTIF.toRGBA8(page);
            
            els.mainImage.classList.add('hidden');
            els.mainCanvas.classList.remove('hidden');
            
            els.mainCanvas.width = page.width;
            els.mainCanvas.height = page.height;
            
            const ctx = els.mainCanvas.getContext('2d');
            const imgData = ctx.createImageData(page.width, page.height);
            imgData.data.set(rgba);
            ctx.putImageData(imgData, 0, 0);

            els.pageInfo.textContent = `Pg ${state.currTiffPage + 1}/${state.tiffPages.length}`;
        }

        // --- THUMBNAILS ---
        function generateThumbnails() {
            els.thumbStrip.innerHTML = '';
            state.files.forEach((file, idx) => {
                const btn = document.createElement('button');
                btn.className = `shrink-0 w-12 h-12 rounded-md overflow-hidden border-2 border-transparent transition opacity-60 hover:opacity-100 bg-slate-700`;
                btn.id = `thumb-${idx}`;
                btn.onclick = () => { state.currIndex = idx; loadCurrentImage(); };

                // Async thumbnail generation
                const img = document.createElement('img');
                img.className = "w-full h-full object-cover";
                
                if (file.name.match(/\.tif/i)) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const ifds = UTIF.decode(e.target.result);
                        UTIF.decodeImage(e.target.result, ifds[0]);
                        const rgba = UTIF.toRGBA8(ifds[0]);
                        // Create tiny canvas
                        const tCan = document.createElement('canvas');
                        tCan.width = ifds[0].width; tCan.height = ifds[0].height;
                        const ctx = tCan.getContext('2d');
                        const idata = ctx.createImageData(tCan.width, tCan.height);
                        idata.data.set(rgba);
                        ctx.putImageData(idata, 0, 0);
                        img.src = tCan.toDataURL();
                    }
                    reader.readAsArrayBuffer(file);
                } else {
                    img.src = URL.createObjectURL(file);
                }
                
                btn.appendChild(img);
                els.thumbStrip.appendChild(btn);
            });
        }

        function updateActiveThumb() {
            document.querySelectorAll('#thumbnailStrip button').forEach(b => b.classList.remove('active-thumb', 'opacity-100'));
            const active = document.getElementById(`thumb-${state.currIndex}`);
            if (active) {
                active.classList.add('active-thumb', 'opacity-100');
                active.scrollIntoView({ behavior: 'smooth', inline: 'center' });
            }
        }

        // --- INTERACTION (Pan, Zoom, Gestures) ---
        
        // Mouse
        els.gestureZone.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            applyZoom(delta);
        });

        els.gestureZone.addEventListener('mousedown', (e) => {
            state.isDragging = true;
            state.dragStart = { x: e.clientX - state.panX, y: e.clientY - state.panY };
        });

        window.addEventListener('mousemove', (e) => {
            if (state.isDragging) {
                state.panX = e.clientX - state.dragStart.x;
                state.panY = e.clientY - state.dragStart.y;
                updateTransform();
            }
        });

        window.addEventListener('mouseup', () => state.isDragging = false);

        // Touch
        els.gestureZone.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                state.isDragging = true;
                state.dragStart = { x: e.touches[0].clientX - state.panX, y: e.touches[0].clientY - state.panY };
            } else if (e.touches.length === 2) {
                state.isDragging = false;
                state.pinchStartDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        });

        els.gestureZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (state.isDragging && e.touches.length === 1) {
                state.panX = e.touches[0].clientX - state.dragStart.x;
                state.panY = e.touches[0].clientY - state.dragStart.y;
                updateTransform();
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const delta = dist / state.pinchStartDist;
                state.pinchStartDist = dist;
                // Slow down pinch speed slightly
                const damping = delta > 1 ? 1 + (delta-1)*0.5 : 1 - (1-delta)*0.5;
                applyZoom(damping);
            }
        });

        els.gestureZone.addEventListener('touchend', () => state.isDragging = false);

        function applyZoom(factor) {
            const newZoom = state.zoom * factor;
            if (newZoom > 0.1 && newZoom < 10) {
                state.zoom = newZoom;
                updateTransform();
            }
        }

        function updateTransform() {
            const style = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            els.mainCanvas.style.transform = style;
            els.mainImage.style.transform = style;
        }

        function resetTransform() {
            state.zoom = 1; state.panX = 0; state.panY = 0;
            updateTransform();
        }

        // --- TOOLS (Crop, Rotate, etc) ---
        
        function prevTiffPage() {
            if (state.tiffPages.length > 1) {
                state.currTiffPage = (state.currTiffPage - 1 + state.tiffPages.length) % state.tiffPages.length;
                renderTiffPage();
            }
        }
        
        function nextTiffPage() {
            if (state.tiffPages.length > 1) {
                state.currTiffPage = (state.currTiffPage + 1) % state.tiffPages.length;
                renderTiffPage();
            }
        }

        function rotate90() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const source = els.mainCanvas.classList.contains('hidden') ? els.mainImage : els.mainCanvas;
            
            const w = source.width || source.naturalWidth;
            const h = source.height || source.naturalHeight;
            
            canvas.width = h;
            canvas.height = w;
            
            ctx.translate(h/2, w/2);
            ctx.rotate(90 * Math.PI / 180);
            ctx.drawImage(source, -w/2, -h/2);
            
            // Put back to main canvas
            els.mainImage.classList.add('hidden');
            els.mainCanvas.classList.remove('hidden');
            els.mainCanvas.width = h;
            els.mainCanvas.height = w;
            els.mainCanvas.getContext('2d').drawImage(canvas, 0, 0);
            
            resetTransform();
        }

        function toggleCrop() {
            state.cropMode = !state.cropMode;
            updateCropUI();
            if (state.cropMode) showToast("Crop Mode: Tap Top-Left, then Bottom-Right");
            state.cropStart = null;
        }

        function updateCropUI() {
            if (state.cropMode) els.cropBtn.classList.add('text-blue-400');
            else els.cropBtn.classList.remove('text-blue-400');
        }

        // Click handler for cropping
        els.canvasWrapper.addEventListener('click', (e) => {
            if (!state.cropMode) return;
            
            // Simple coordinate mapping logic
            // Note: Accurate cropping requires unmapping the CSS transform. 
            // For this version, we assume the user fits the image to screen or we take visual approximation.
            // A robust solution maps screen coords -> transformed coords -> canvas coords.
            
            // To keep it reliable for this demo: We use the Center of the viewport as reference or simple visual clicks.
            // Let's implement a visual reset for cropping to ensure accuracy.
            
            if (state.zoom !== 1) {
                resetTransform();
                showToast("Zoom reset for accurate cropping");
                return;
            }

            const rect = els.mainCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (els.mainCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (els.mainCanvas.height / rect.height);

            if (!state.cropStart) {
                state.cropStart = { x, y };
                showToast("Start set. Tap End point.");
            } else {
                const start = state.cropStart;
                const width = Math.abs(x - start.x);
                const height = Math.abs(y - start.y);
                const sx = Math.min(start.x, x);
                const sy = Math.min(start.y, y);

                const tempC = document.createElement('canvas');
                tempC.width = width; tempC.height = height;
                tempC.getContext('2d').drawImage(els.mainCanvas, sx, sy, width, height, 0, 0, width, height);

                els.mainCanvas.width = width;
                els.mainCanvas.height = height;
                els.mainCanvas.getContext('2d').drawImage(tempC, 0, 0);
                
                state.cropMode = false;
                state.cropStart = null;
                updateCropUI();
                showToast("Cropped!");
            }
        });

        function showHistogram() {
            // Simple alert for now, or a modal overlay
            const ctx = els.mainCanvas.getContext('2d');
            const w = els.mainCanvas.width; const h = els.mainCanvas.height;
            // Sampling center pixels for speed
            const data = ctx.getImageData(w/2 - 50, h/2 - 50, 100, 100).data;
            let r=0, g=0, b=0;
            for(let i=0; i<data.length; i+=4) { r+=data[i]; g+=data[i+1]; b+=data[i+2]; }
            const pix = data.length/4;
            showToast(`Avg Color: R${Math.floor(r/pix)} G${Math.floor(g/pix)} B${Math.floor(b/pix)}`);
        }

        // --- EXPORT ---
        function exportToJPG() {
            if (state.currIndex < 0) return;
            const link = document.createElement('a');
            const src = els.mainCanvas.classList.contains('hidden') ? els.mainImage : els.mainCanvas;
            
            // If it's an IMG tag, draw to canvas first
            let finalCanvas = src;
            if (src.tagName === 'IMG') {
                finalCanvas = document.createElement('canvas');
                finalCanvas.width = src.naturalWidth;
                finalCanvas.height = src.naturalHeight;
                finalCanvas.getContext('2d').drawImage(src, 0, 0);
            }

            link.download = 'exported_image.jpg';
            link.href = finalCanvas.toDataURL('image/jpeg', 0.9);
            link.click();
        }

        async function exportAllZip() {
            if (state.files.length === 0) return;
            showToast("Preparing ZIP...");
            const zip = new JSZip();
            
            // Helper to get data URL from file
            const fileToData = (file) => new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if(file.name.match(/\.tif/)) {
                        // Convert TIFF to JPG for zip
                        const ifds = UTIF.decode(e.target.result);
                        UTIF.decodeImage(e.target.result, ifds[0]);
                        const rgba = UTIF.toRGBA8(ifds[0]);
                        const c = document.createElement('canvas');
                        c.width = ifds[0].width; c.height = ifds[0].height;
                        const ctx = c.getContext('2d');
                        const idata = ctx.createImageData(c.width, c.height);
                        idata.data.set(rgba);
                        ctx.putImageData(idata, 0, 0);
                        resolve(c.toDataURL('image/jpeg', 0.8).split(',')[1]);
                    } else {
                        resolve(e.target.result.split(',')[1]); // Assume base64
                    }
                }
                if (file.name.match(/\.tif/)) reader.readAsArrayBuffer(file);
                else reader.readAsDataURL(file);
            });

            for (let i = 0; i < state.files.length; i++) {
                const file = state.files[i];
                const data = await fileToData(file);
                zip.file(`image_${i+1}.jpg`, data, {base64: true});
            }

            const content = await zip.generateAsync({type:"blob"});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = "all_images.zip";
            link.click();
            showToast("ZIP Downloaded");
        }

        // --- UTILS ---
        function showToast(msg) {
            const t = document.createElement('div');
            t.className = "fixed top-20 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-4 py-2 rounded-full shadow-xl border border-slate-600 z-50 animate-bounce text-sm";
            t.innerText = msg;
            document.body.appendChild(t);
            setTimeout(() => t.remove(), 2500);
        }
    </script>
</body>
</html>
