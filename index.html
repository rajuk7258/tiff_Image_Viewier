<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ProView TIFF PWA</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    
    <style>
        body { touch-action: none; overscroll-behavior: none; -webkit-tap-highlight-color: transparent; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        #canvasWrapper {
            background-image: linear-gradient(45deg, #1e293b 25%, transparent 25%), linear-gradient(-45deg, #1e293b 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #1e293b 75%), linear-gradient(-45deg, transparent 75%, #1e293b 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas, img { 
            transform-origin: 0 0; 
            will-change: transform;
        }
        .active-thumb { border-color: #3b82f6; opacity: 1; transform: scale(1.05); }
        
        /* Floating Nav Buttons Hover Effect */
        .nav-btn:hover { background-color: rgba(59, 130, 246, 0.5); }
    </style>
</head>
<body class="bg-slate-900 text-white h-[100dvh] flex flex-col overflow-hidden font-sans select-none">

    <header class="bg-slate-800/90 backdrop-blur border-b border-slate-700 p-3 flex items-center justify-between shrink-0 z-20">
        <div class="flex items-center gap-3">
            <div class="p-1.5 bg-blue-600 rounded shadow-lg shadow-blue-500/20">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
            </div>
            <h1 class="font-bold tracking-wide text-base">ProView <span class="text-blue-400">TIFF</span></h1>
        </div>

        <div class="flex gap-2">
            <button onclick="resetView()" class="hidden sm:flex bg-slate-700 p-2 rounded-full hover:bg-slate-600" title="Reset View">
                <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/></svg>
            </button>
            <input type="file" id="fileInput" multiple accept=".tif,.tiff,image/*" class="hidden">
            <button onclick="document.getElementById('fileInput').click()" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-1.5 rounded-full text-sm font-medium shadow-lg active:scale-95 transition">
                Open
            </button>
        </div>
    </header>

    <main class="flex-1 relative overflow-hidden flex items-center justify-center bg-slate-950" id="gestureZone">
        
        <div id="emptyState" class="flex flex-col items-center text-slate-600 p-8 text-center pointer-events-none">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-4 opacity-30" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
            <p class="text-lg font-medium text-slate-500">No Images Selected</p>
        </div>

        <div id="loader" class="hidden absolute inset-0 z-50 bg-slate-900/80 flex flex-col items-center justify-center backdrop-blur-sm">
            <div class="w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mb-2"></div>
            <p class="text-blue-400 text-xs font-mono animate-pulse">PROCESSING</p>
        </div>

        <div id="canvasWrapper" class="w-full h-full flex items-center justify-center overflow-hidden hidden relative">
            <canvas id="mainCanvas" class="shadow-2xl"></canvas>
            <img id="mainImage" class="hidden shadow-2xl" />
            <div id="cropOverlay" class="hidden absolute border-2 border-blue-500 bg-blue-500/10 pointer-events-none z-10"></div>
        </div>

        <button onclick="prevFile()" class="hidden md:flex nav-btn absolute left-4 top-1/2 -translate-y-1/2 bg-black/30 backdrop-blur p-3 rounded-full text-white/70 hover:text-white transition z-40">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
        </button>
        <button onclick="nextFile()" class="hidden md:flex nav-btn absolute right-4 top-1/2 -translate-y-1/2 bg-black/30 backdrop-blur p-3 rounded-full text-white/70 hover:text-white transition z-40">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
        </button>

        <div id="fileInfo" class="hidden absolute top-4 left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur-md px-4 py-2 rounded-full text-xs border border-white/10 pointer-events-auto flex items-center gap-3 shadow-xl z-40">
            <span id="fileName" class="text-blue-200 font-medium truncate max-w-[120px]">filename.tif</span>
            <span class="text-slate-500">|</span>
            
            <div id="pageControls" class="flex items-center gap-2 hidden">
                <button onclick="prevTiffPage()" class="p-1 hover:text-blue-400 active:scale-95"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg></button>
                <span id="pageInfo" class="text-slate-300 font-mono">1/1</span>
                <button onclick="nextTiffPage()" class="p-1 hover:text-blue-400 active:scale-95"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg></button>
            </div>
            
            <div id="simpleCounter" class="text-slate-300">1/1</div>
        </div>

        <button id="installBtn" class="hidden absolute bottom-24 right-4 bg-blue-600 text-white px-5 py-2 rounded-full shadow-xl z-50 text-sm font-bold flex items-center gap-2 animate-bounce">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
            Install App
        </button>
    </main>

    <div id="mobileToolbar" class="bg-slate-900/95 backdrop-blur border-t border-slate-800 p-2 flex justify-between items-center pb-safe z-30 overflow-x-auto">
        <button onclick="prevFile()" class="flex flex-col items-center min-w-[60px] p-2 text-slate-400 active:text-blue-400 active:scale-95 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
            <span class="text-[10px] mt-1">Prev Img</span>
        </button>

        <button onclick="rotate90()" class="flex flex-col items-center min-w-[60px] p-2 text-slate-400 active:text-blue-400 active:scale-95 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
            <span class="text-[10px] mt-1">Rotate</span>
        </button>

        <button onclick="toggleCrop()" id="cropBtn" class="flex flex-col items-center min-w-[60px] p-2 text-slate-400 active:text-blue-400 active:scale-95 transition relative">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>
            <span class="text-[10px] mt-1">Crop</span>
            <div id="cropBadge" class="hidden absolute top-1 right-2 w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
        </button>

        <button onclick="exportToJPG()" class="flex flex-col items-center min-w-[60px] p-2 text-slate-400 active:text-blue-400 active:scale-95 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
            <span class="text-[10px] mt-1">Save</span>
        </button>

        <button onclick="nextFile()" class="flex flex-col items-center min-w-[60px] p-2 text-slate-400 active:text-blue-400 active:scale-95 transition">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            <span class="text-[10px] mt-1">Next Img</span>
        </button>
    </div>

    <footer class="bg-slate-800 border-t border-slate-700 h-16 shrink-0 flex items-center px-2 gap-2 overflow-x-auto hide-scrollbar z-20" id="thumbnailStrip"></footer>

    <script>
        // --- STATE ---
        const state = {
            files: [],
            currIndex: -1,
            tiffPages: [],
            currTiffPage: 0,
            currentTiffBuffer: null,
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            swipeStart: { x: 0, y: 0, time: 0 }, // For swipe detection
            pinchStartDist: 0,
            pinchStartZoom: 1,
            cropMode: false,
            cropStart: null
        };

        const els = {
            fileInput: document.getElementById('fileInput'),
            canvasWrapper: document.getElementById('canvasWrapper'),
            mainCanvas: document.getElementById('mainCanvas'),
            mainImage: document.getElementById('mainImage'),
            emptyState: document.getElementById('emptyState'),
            loader: document.getElementById('loader'),
            fileInfo: document.getElementById('fileInfo'),
            fileName: document.getElementById('fileName'),
            pageControls: document.getElementById('pageControls'),
            pageInfo: document.getElementById('pageInfo'),
            simpleCounter: document.getElementById('simpleCounter'),
            thumbStrip: document.getElementById('thumbnailStrip'),
            gestureZone: document.getElementById('gestureZone'),
            cropBtn: document.getElementById('cropBtn'),
            cropBadge: document.getElementById('cropBadge'),
            installBtn: document.getElementById('installBtn')
        };

        // --- INIT ---
        els.fileInput.addEventListener('change', handleFileSelect);
        
        // PWA Install
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            els.installBtn.classList.remove('hidden');
        });
        els.installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) return;
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            if (outcome === 'accepted') els.installBtn.classList.add('hidden');
            deferredPrompt = null;
        });

        if ('serviceWorker' in navigator) navigator.serviceWorker.register('service-worker.js').catch(console.error);

        // --- FILE LOADING ---
        async function handleFileSelect(e) {
            const raw = Array.from(e.target.files);
            const valid = raw.filter(f => f.type.startsWith('image/') || f.name.match(/\.(tif|tiff)$/i));
            if (valid.length === 0) return showToast("No valid images");

            state.files = valid;
            state.currIndex = 0;
            
            els.emptyState.classList.add('hidden');
            els.canvasWrapper.classList.remove('hidden');
            els.canvasWrapper.classList.add('flex');
            els.fileInfo.classList.remove('hidden');

            generateThumbnails();
            await loadCurrentImage();
        }

        async function loadCurrentImage() {
            if (state.currIndex < 0) return;
            
            resetView();
            state.cropMode = false;
            state.cropStart = null;
            updateCropUI();
            
            const file = state.files[state.currIndex];
            els.fileName.textContent = file.name;
            els.loader.classList.remove('hidden');
            updateActiveThumb();

            // Toggle Page Controls
            els.pageControls.classList.add('hidden');
            els.simpleCounter.classList.remove('hidden');
            els.simpleCounter.textContent = `${state.currIndex + 1} / ${state.files.length}`;

            try {
                if (file.name.match(/\.(tif|tiff)$/i)) {
                    await loadTiff(file);
                } else {
                    await loadStandard(file);
                }
            } catch (e) {
                console.error(e);
                showToast("Error loading image");
            } finally {
                els.loader.classList.add('hidden');
            }
        }

        function loadStandard(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    els.mainCanvas.classList.add('hidden');
                    els.mainImage.classList.remove('hidden');
                    els.mainImage.src = e.target.result;
                    els.mainImage.onload = () => {
                        const c = els.mainCanvas;
                        c.width = els.mainImage.naturalWidth;
                        c.height = els.mainImage.naturalHeight;
                        c.getContext('2d').drawImage(els.mainImage, 0, 0);
                        els.mainImage.classList.add('hidden');
                        els.mainCanvas.classList.remove('hidden');
                        state.tiffPages = [];
                        centerImage();
                        resolve();
                    }
                }
                reader.readAsDataURL(file);
            });
        }

        async function loadTiff(file) {
            const buffer = await file.arrayBuffer();
            const ifds = UTIF.decode(buffer);
            state.tiffPages = ifds;
            state.currTiffPage = 0;
            state.currentTiffBuffer = buffer;
            
            if(ifds.length > 1) {
                els.pageControls.classList.remove('hidden');
                els.simpleCounter.classList.add('hidden');
            }
            
            await renderTiffPage();
        }

        async function renderTiffPage() {
            if (!state.tiffPages.length) return;
            const page = state.tiffPages[state.currTiffPage];
            UTIF.decodeImage(state.currentTiffBuffer, page);
            const rgba = UTIF.toRGBA8(page);
            
            els.mainCanvas.width = page.width;
            els.mainCanvas.height = page.height;
            const ctx = els.mainCanvas.getContext('2d');
            const imgData = ctx.createImageData(page.width, page.height);
            imgData.data.set(rgba);
            ctx.putImageData(imgData, 0, 0);

            els.pageInfo.textContent = `Pg ${state.currTiffPage + 1}/${state.tiffPages.length}`;
            centerImage();
        }

        // --- GESTURES & SWIPE ---
        function centerImage() {
            const wrap = els.canvasWrapper.getBoundingClientRect();
            const cnv = els.mainCanvas;
            // Simple fit containment
            const scale = Math.min(wrap.width / cnv.width, wrap.height / cnv.height) * 0.95;
            
            state.zoom = scale < 1 ? scale : 1;
            // Centering logic accounting for transform origin 0 0
            state.panX = (wrap.width - cnv.width * state.zoom) / 2;
            state.panY = (wrap.height - cnv.height * state.zoom) / 2;
            
            // Adjust for canvas space vs screen space mismatch if unscaled
            if(state.zoom === 1) {
                 state.panX = (wrap.width - cnv.width)/2;
                 state.panY = (wrap.height - cnv.height)/2;
            }

            updateTransform();
        }
        
        function resetView() { if(els.mainCanvas.width > 0) centerImage(); }

        // --- FILE NAVIGATION ---
        function nextFile() {
            if (state.files.length === 0) return;
            if (state.currIndex < state.files.length - 1) {
                state.currIndex++;
                loadCurrentImage();
            } else {
                showToast("End of list");
            }
        }

        function prevFile() {
            if (state.files.length === 0) return;
            if (state.currIndex > 0) {
                state.currIndex--;
                loadCurrentImage();
            } else {
                showToast("Start of list");
            }
        }

        // --- TOUCH EVENTS (Swipe & Pan) ---
        els.gestureZone.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                state.isDragging = true;
                state.dragStart = { x: e.touches[0].clientX - state.panX, y: e.touches[0].clientY - state.panY };
                // Record for swipe
                state.swipeStart = { x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() };
            } else if (e.touches.length === 2) {
                state.isDragging = false;
                state.pinchStartDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                state.pinchStartZoom = state.zoom;
            }
        });

        els.gestureZone.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            if (state.isDragging && e.touches.length === 1) {
                // If checking for swipe, only pan if zoom > 1 (ish) or if strict pan mode
                // But generally users expect pan to work always. Swipe is detected on end.
                state.panX = e.touches[0].clientX - state.dragStart.x;
                state.panY = e.touches[0].clientY - state.dragStart.y;
                updateTransform();
            } else if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const scale = dist / state.pinchStartDist;
                state.zoom = state.pinchStartZoom * scale;
                updateTransform();
            }
        }, { passive: false });

        els.gestureZone.addEventListener('touchend', (e) => {
            state.isDragging = false;
            
            // Check Swipe (Only if single touch ended and not zoomed in much)
            // If e.changedTouches is available
            if (e.changedTouches.length > 0 && state.zoom < 1.2 && !state.cropMode) {
                const endX = e.changedTouches[0].clientX;
                const endY = e.changedTouches[0].clientY;
                const diffX = endX - state.swipeStart.x;
                const diffY = endY - state.swipeStart.y;
                const timeDiff = Date.now() - state.swipeStart.time;

                // Thresholds: min distance 50px, max time 500ms, mostly horizontal
                if (Math.abs(diffX) > 50 && Math.abs(diffY) < 50 && timeDiff < 500) {
                    if (diffX > 0) prevFile(); // Swipe Right -> Prev
                    else nextFile();           // Swipe Left -> Next
                }
            }
        });

        function updateTransform() {
            const style = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            els.mainCanvas.style.transform = style;
        }

        // --- TIFF PAGE NAV ---
        function prevTiffPage() {
            if (state.tiffPages.length > 1) {
                state.currTiffPage = (state.currTiffPage - 1 + state.tiffPages.length) % state.tiffPages.length;
                renderTiffPage();
            }
        }
        function nextTiffPage() {
            if (state.tiffPages.length > 1) {
                state.currTiffPage = (state.currTiffPage + 1) % state.tiffPages.length;
                renderTiffPage();
            }
        }

        // --- ROTATE / CROP / EXPORT ---
        function rotate90() {
            const src = els.mainCanvas;
            const temp = document.createElement('canvas');
            const dim = { w: src.width, h: src.height };
            
            temp.width = dim.h;
            temp.height = dim.w;
            
            const ctx = temp.getContext('2d');
            ctx.translate(dim.h/2, dim.w/2);
            ctx.rotate(90 * Math.PI / 180);
            ctx.drawImage(src, -dim.w/2, -dim.h/2);
            
            src.width = dim.h;
            src.height = dim.w;
            src.getContext('2d').drawImage(temp, 0, 0);
            centerImage();
        }

        function toggleCrop() {
            state.cropMode = !state.cropMode;
            updateCropUI();
            if (state.cropMode) showToast("Crop: Tap Top-Left, then Bottom-Right");
            state.cropStart = null;
        }

        function updateCropUI() {
            if (state.cropMode) {
                els.cropBtn.classList.add('text-blue-400', 'bg-slate-800');
                els.cropBadge.classList.remove('hidden');
                els.mainCanvas.style.cursor = 'crosshair';
            } else {
                els.cropBtn.classList.remove('text-blue-400', 'bg-slate-800');
                els.cropBadge.classList.add('hidden');
                els.mainCanvas.style.cursor = 'default';
                document.getElementById('cropOverlay').classList.add('hidden');
            }
        }

        els.gestureZone.addEventListener('click', (e) => {
            if (!state.cropMode) return;
            const rect = els.mainCanvas.getBoundingClientRect();
            const visualX = e.clientX - rect.left;
            const visualY = e.clientY - rect.top;
            const actualX = visualX / state.zoom;
            const actualY = visualY / state.zoom;

            if (!state.cropStart) {
                state.cropStart = { x: actualX, y: actualY };
                showToast("Start point set");
                const overlay = document.getElementById('cropOverlay');
                overlay.classList.remove('hidden');
                overlay.style.left = e.clientX + 'px';
                overlay.style.top = e.clientY + 'px';
                overlay.style.width = '0px'; overlay.style.height = '0px';
            } else {
                const start = state.cropStart;
                const end = { x: actualX, y: actualY };
                const x = Math.min(start.x, end.x);
                const y = Math.min(start.y, end.y);
                const w = Math.abs(end.x - start.x);
                const h = Math.abs(end.y - start.y);

                if (w < 10 || h < 10) return showToast("Crop too small");

                const temp = document.createElement('canvas');
                temp.width = w; temp.height = h;
                temp.getContext('2d').drawImage(els.mainCanvas, x, y, w, h, 0, 0, w, h);
                els.mainCanvas.width = w; els.mainCanvas.height = h;
                els.mainCanvas.getContext('2d').drawImage(temp, 0, 0);
                
                state.cropMode = false;
                updateCropUI();
                centerImage();
                showToast("Cropped!");
            }
        });

        // --- UTILS ---
        function showToast(msg) {
            const t = document.createElement('div');
            t.className = "fixed top-24 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-3 rounded-full shadow-2xl border border-slate-600 z-[100] animate-bounce text-sm font-semibold";
            t.innerText = msg;
            document.body.appendChild(t);
            setTimeout(() => t.remove(), 2500);
        }

        function generateThumbnails() {
            els.thumbStrip.innerHTML = '';
            state.files.forEach((file, idx) => {
                const btn = document.createElement('button');
                btn.className = `shrink-0 w-12 h-12 rounded-md overflow-hidden border-2 border-transparent transition opacity-60 hover:opacity-100 bg-slate-700 relative`;
                btn.id = `thumb-${idx}`;
                btn.onclick = () => { state.currIndex = idx; loadCurrentImage(); };
                
                const lbl = document.createElement('span');
                lbl.innerText = idx+1;
                lbl.className = "absolute bottom-0 right-0 bg-black/50 text-[8px] px-1 text-white";
                btn.appendChild(lbl);
                
                const img = document.createElement('img');
                img.className = "w-full h-full object-cover";
                img.src = URL.createObjectURL(file); 
                btn.appendChild(img);
                els.thumbStrip.appendChild(btn);
            });
        }
        function updateActiveThumb() {
            document.querySelectorAll('#thumbnailStrip button').forEach(b => b.classList.remove('active-thumb', 'opacity-100'));
            const active = document.getElementById(`thumb-${state.currIndex}`);
            if (active) {
                active.classList.add('active-thumb', 'opacity-100');
                active.scrollIntoView({ behavior: 'smooth', inline: 'center' });
            }
        }
        function exportToJPG() {
            if (state.currIndex < 0) return;
            const link = document.createElement('a');
            link.download = `ProView_${Date.now()}.jpg`;
            link.href = els.mainCanvas.toDataURL('image/jpeg', 0.9);
            link.click();
        }
    </script>
</body>
</html>
